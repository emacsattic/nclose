<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
  <head>
    <title>NClosEmacs: An Emacs-based Expert System Framework</title>
    <meta name="generator" content="muse.el">
    <meta http-equiv="Content-Type"
          content="text/html; charset=iso-8859-1">
    <style type="text/css">
body {
  background: white; color: black;
  margin-left: 3%; margin-right: 7%;
}

p { margin-top: 1% }
p.verse { margin-left: 3% }

.example { margin-left: 3% }

h2 {
  margin-top: 25px;
  margin-bottom: 0px;
}
h3 { margin-bottom: 0px; }
    </style>
  </head>
  <body>
    <h1>NClosEmacs: An Emacs-based Expert System Framework</h1>
    <!-- Page published by Emacs Muse begins here -->
<p>This document describes NClosEmacs, a tentative implementation of the
NClose rules engine in ELisp for embedding expert system functionality
in the Emacs environment.</p>

<p>In addition, this implementation is experimental in that it
investigates the use of <em>modern</em> programming approaches in this new
implementation, most of which were only budding when NClose itself was
designed in the early eighties.</p>

<p>As such, it is still with a certain pride, after all these years, that I qualify the following work as research in progress.</p>

<h2>Introduction and historical background</h2>

<p class="first">NClose is an original evaluation algorithm designed for research on
rule-based systems, with which specific domain applications in
Medicine were explored in the mid-eighties, at the Robotics Institute,
Carnegie-Mellon University.</p>

<p>At that time NClose emerged as a first result in an effort to pursue
the development of computer programs capable of displaying (hopefully)
intelligent problem-solving behaviour.  This approach to Artificial
Intelligence was unsurprisingly inspired from the prevalent school of
thought at CMU led by Allen Newell and Herbert Simon.  Work by
Newell, <a href="http://www.aaai.org/aitopics/assets/PDF/AIMag02-02-001.pdf">&quot;The Knowledge Level&quot;</a> in particular, but research at MIT
driven by Pete Szolovits, <a href="http://groups.csail.mit.edu/medg/people/psz/ftp/AIM82/">&quot;Artificial Intelligence in Medicine&quot;</a>, for
instance, and at Stanford with authors such as Buchanan, Feigenbaum,
Shortliffe and Fagan also proved inspirational, specifically in
relation to domain applications.</p>

<p>A second angle which drove these early research effort was the
realisation that &quot;rules&quot; or &quot;productions&quot; could be envisioned as both
representing <em>computation</em> elements, within a computer science
perspective, and <em>knowledge</em> units, in the larger cognitive sciences
framework which was budding from AI research at the time.  This
duality of views in itself provided an exploratory bridge between
computing processes and cognitive behaviour which, with the upcoming
availability of PCs and graphical user interfaces, readily lent itself
to an experimental mode of research.</p>

<p>From the late eighties to the late nineties, this experimental mode
would morph into more implementation-oriented work, culminating in the
very successful releases of a series of commercial tools and
environments at the front edge of the then nascent major trends in an
emerging software industry: graphical user interfaces and
object-oriented programming languages, which are both now firmly
established as our common base infrastructure.</p>

<p>Over time several implementations of the base NClose algorithm were
developed in various programming languages including LISP (MacLisp,
LeLisp, and ZetaLisp chiefly), and later Pascal, C and C++.  NClose
evaluation constituted the core of the rule engine found in the
commercial products Nexpert, and Nexpert Object, released by Neuron
Data from 1985 onward.</p>


<h2>NClose in Emacs</h2>

<p class="first">This package contains a preliminary implementation of NClose in ELisp,
the dialect of the Lisp programming language used in both GNU Emacs
and XEmacs (collectively called Emacs in this document).  Users of Emacs
commonly write ELisp code to extend and to customize Emacs as they
require.</p>

<p>This document does not dwell on the NClose algorithm itself, a formal
description of which can be found in <a href="http://www.ri.cmu.edu/pubs/pub_77.html">Rappaport and Chauvet, 1984</a>, and
rather focuses on several facets of its implementation in ELisp, with
emphasis on the experimental approach to this revisited development.</p>

<p>This implementation departs from the somewhat older implementations in
early pre-Common Lisp dialects (namely MacLisp and ZetaLisp) which was
leveraged in our AI research work.  In particular, ELisp offers
&quot;advising functions&quot; which are useful for Aspect Oriented Programming
(AOP).  AOP, which originated with Gregor Kiczales at Xerox PARC,
helps programmers separate so-called cross-cutting concerns,
i.e. functionality which has an impact on all the functions of a
program, from the program code itself.  (Logging is the traditional
example of a cross-cutting concern.)  The AOP flavor provided by
advising functions in Emacs prompted revisiting the NClose algorithm
with an eye towards proper identification of cross-cutting concerns.</p>

<p>Another revision of the original design ideas behind NClose was deemed
necessary as Emacs is, for all purposes of this implementation, the
unique communication channel with the end-user.  As one of the
distinguishing features of NClose, and the ensuing Nexpert
implementations and commercial products, is precisely its handling of
user interactions, the embedding into Emacs both restricted and
enhanced what we used to implement in windowing environments and
graphical user interfaces.  Living in Emacs, text naturally becomes
the primary user interface through which commands are issued and
knowledge bases loaded and run.  Special buffers play roles otherwise
devolved to windows or menus in previous implementations.  New usages
may be envisioned where knowledge-driven problem solving seamlessly
blends into text documents produced by the user.</p>

<p>The following sections provide an overview of the design options
selected in the current NClosEmacs implementation.</p>

<h3>ELisp Implementation</h3>

<p class="first">The main implementation file is <code>nclose.el</code>.  It loads the
various ELisp files required, installs a new major mode for NClose
rule bases and inits the rules engine.</p>

<p>Each large functional chunk is implemented in its own ELisp file named
somewhat after its main role in the NClose algorithm.  More detailed
explanations may be found in @xref{Implementation}.</p>

<p>NClosEmacs relies on the ELisp evaluator for its rules evaluation
engine.  Each piece of data in the left- and right-hand sides of
rules, usually called <em>signs</em>, <em>variables</em> or simply <em>data</em> in the rest of
the document, and each <em>hypothesis</em> is actually implemented as an ELisp
symbol.  This means that the value of a sign is obtained by typing its
name at the top level Lisp listener.  For instance:
<code>ACETATE-CYPROTERONE</code> and <code>(eval
'ACETATE-CYPROTERONE)</code> both return the value of the sign
ACETATE-CYPROTERONE.  Unknown signs are simply unbound ELisp symbols.</p>

<p>Another nice consequence of the reuse of the evaluator is that
conditions patterns in left-hand sides may be expressed directly in
Lisp.  Similarly actions in the righ-hand sides may use Lisp functions
directly.  Pattern evaluation uses the error signalling mechanism of
ELisp to trigger backward chaining if the unbound sign encountered is
in fact an hypothesis, or a question to the user if simply a sign.
In <code>unify.el</code> the basic LHS evaluation is as follows:</p>

<pre class="example">
(defun nclose-get-unification (pattern)
  &quot;Interactive unification of pattern&quot;
  (condition-case error
      (eval pattern)
    (void-variable
     (sign-writer (cadr error) (sign-reader (cadr error)))
     ;; Recurse
     (nclose-get-unification pattern)
    )
    )
)
</pre>

<p>The idea is that when the (Lisp) evaluation of the pattern fails on an
unbound symbol, the error catching mechanism considers it as an
unknown sign or hypothesis and accordingly assigns a value read
possibly interactively, and retries.  This process recursively
evaluates all required signs in the LHS to produce the final
unification result, here a true or false value.</p>

<p>The <code>sign-writer</code> and <code>sign-reader</code> high level
getter/setter functions for signs are separately coded as they may be
advised in order to implement side-effects.</p>

<p>Similarly a rule RHS is passed to the Lisp evaluator for execution
with the sequence of Lisp forms implicitly and-ed, as in:</p>

<pre class="example">
(defun and-eval-rhs (rhs)
  &quot;Recursively execute the sequential execution of RHS forms&quot;
  (cond
   ((null rhs) t)
   (t (and (eval (car rhs)) (and-eval-rhs (cdr rhs))))
   )
)
</pre>

<p>This works provided all RHS operators are pre-defined to call the
advised functions if necessary.  This is in particular the case for
the ubiquitous <code>@SET</code> operator which expects exactly a sign
as its first argument and a value as the second argument.  In the file
<code>rhs.el</code>, this operator, for instance, is implemented as a
Lisp macro:</p>

<pre class="example">
(defmacro @set (var val)
  &quot;External RHS assignment operator&quot;
  (progn (sign-writer var (nclose-get-unification val)) t)
)
</pre>

<p>This example implementation of a RHS operator shows the important
features to keep in mind.  Execution indeed returns a boolean value;
remember the implicit and in the sequence of RHS forms execution.
Returning <code>nil</code> would stop further execution of the
RHS. (This crude control mechanism could be useful to an advising
function for instance.)</p>

<p>The RHS value assignment itself is a two-step process: the value is
computed, which may entail asking the user for input, hence the call
to the generic <code>nclose-get-unification</code>
evaluation/unification function also used in LHS patterns evaluation;
and then it is assigned to the said sign through the standard setter,
which as previously mentioned may itself be advised.</p>

<p>Other domain-specific operators may be developed by following the
same simple design method.  An interesting possibility is, of course,
to call Emacs' text and buffer functions from the RHS of NClose rules,
opening up a whole scope of applications with text documents
co-produced, in form or content or both, by the user and a rule-based
expert system.</p>


<h3>Aspect Oriented Programming</h3>

<p class="first">The experimental part of this new implementation of NClose relies on
using Aspect Oriented Programming ideas, and more specifically a
recent evolution known as <a href="http://www.swa.hpi.uni-postdam.de/cop/">Context Oriented Programming</a>, where
different cross-cutting concerns are implemented in <em>layers</em> separately
activated as needed.</p>

<p>Although not all features of NClose were yet reviewed for this version
of the implementation, at least two were immediately identified as
appropriate candidates for an AOP approach:</p>

<ul>
<li>Gating: the core NClose forward chaining process</li>
<li>Logging: keeping a trace of the expert system session execution</li>
</ul>

<p>The &quot;gating&quot; process in NClose is a form of forward chaining, going
from known signs or data to hypotheses.  In contrast to RETE-like
implementations where individual conditions in separate rules are
compiled into a automate network, with known data acting as tokens
moving from one vertex to another as they match the condition node,
the somewhat simpler implementation in NClose uses a &quot;gate&quot;, which,
when a sign becomes known, decides which hypotheses should be posted
for later evaluation.</p>

<p>In order to implement gating, a gating-layer is created as a series of
advising functions in ELisp.  Given that the core backward chaining is
implemented through an agenda, a last-in first-out stack of hypotheses
posted for evaluation in bacward chaining mode, the gating-layer
addresses concerns:</p>

<ul>
<li>initialization time, for the setup of the data structures
responsible for handling gating;</li>
<li>rule compilation, to handle dependencies between hypotheses and
signs discovered when parsing LHSes;</li>
<li>execution time, each time a value is assigned to a piece of data,
i.e. when it becomes known.</li>
</ul>

<p>The layer is hence implemented as three advising functions, gathered
with other layers in the <code>advice.el</code> file.  The following
advising function, for instance:</p>

<pre class="example">
(defadvice sign-compile (after gating-layer (sign hypo))
  &quot;Builds the forward association list, hypo is nil when RHS are compiled&quot;
  (if hypo (plist-push sign hypo))
)
</pre>

<p>advises the <code>sign-compile</code> function, called at rule
compilation time, and adds the rule's hypothesis to the parsed sign
forward association list.  This forward association list is later
used, at runtime, to push hypotheses on the agenda when signs become
known.</p>

<p>In order to implement a minimal logging facility, another layer is
implemented in <code>advice.el</code>.  The functions in this layer
simply advise all of the interactive command functions, keeping track
of all interactions with the user, as well as the evaluation
functions, keeping trace of the expert system's deductions as the
session progresses.  These traces are stored in a special Emacs buffer
named <code>*nclose-log*</code> and addressable through the usual set
of Emacs buffer commands.</p>

<p>Advising functions are enabled and activated by default in the same
file:</p>

<pre class="example">
;; Enable/Disable layers as required
(ad-enable-regexp &quot;gating-layer&quot;)
(ad-enable-regexp &quot;log-layer&quot;)

;; Activate advising functions
(ad-activate-regexp &quot;gating-layer&quot;)
(ad-activate-regexp &quot;log-layer&quot;)
</pre>

<p>other variations are of course possible, since Emacs' advising
functions may be enabled and disabled using regexp patterns rather
than names.</p>


<h3>Front End</h3>

<p class="first">The front-end of this NClose implementation is unsurprisingly
text-oriented and well-integrated with Emacs.  The purpose of the
default front-end is to assist in the authoring and running of rule
bases from within Emacs.</p>

<p>The NClose rules engine is manually loaded by issuing the standard
Emacs command <code>M-x load-file</code> on the master NClose
<code>nclose.el</code> file (with the .elc extension if it has been
compiled at installation).  This may also be placed in the
<code>.emacs</code> initialization file.</p>

<p>The rule base itself is a text document edited in a standard Emacs
buffer.  @xref{Authoring Knowledge Bases}, for the
actual syntax of rules declarations.  The user &quot;loads&quot; a rule base in
memory simply by evaluating the buffer containing its text, the
<code>M-x eval-current-buffer</code> in Emacs.</p>

<p>NClose provides a number of commands, implemented as interactive ELisp
functions invoked through the usual <code>M-x</code> prefix to setup
and run an expert session.  In addition, traces and execution logs may
be provided in NClose-specific buffers such as
<code>*nclose-log*</code>.</p>

<p>The <code>nclose.el</code> file also provides a minimal major mode for
text-based rule bases.  At this stage, the major mode is only
concerned with highlighting the inference process as it progresses
through the rule base.  Hypotheses under evaluation are highlighted as
they are pushed and popped from the agenda; their final status, true
or false, is color-coded.  NClose keywords are also font-locked for
easier readability.  (The NClose major mode is still pretty much
experimental and additional features may be added as the
implementation is revised.)</p>



<h2>Authoring Knowledge Bases</h2>

<p class="first">Rule bases for NClose are simple text documents which can be edited in
Emacs.  These rule base text documents follow the Lisp syntax
conventions, and more specifically the ELisp conventions.  Comments
lines begin with the <code>;</code> character.  The body of the rule
base is constituted of well-balanced Lisp forms, one for each rule in
the knowledge base.</p>

<h3>Writing rules</h3>

<p class="first">NClose provides a high-level Lisp macro to declare a rule.</p>

<pre class="example">
(add-to-kb
  (@LHS= *pattern-lisp-form*)
  (@hypo *hypothesis*)
  [(@RHS= [*RHS-lisp-form*]+) *string-documentation*]
)
</pre>

<p>The macro parses four arguments, the last two being optional:</p>

<ul>
<li><em>pattern-lisp-form</em> is a lisp form expressing a boolean computation
with an ultimate true/false value.  It usually is an AND/OR tree of
several elementary conditions involving any of the standard Lisp
functions, namely: <code>(string= &lt; &gt; = /= &gt;= &lt;= + - * / and or not
null yes no Yes No)</code>.  Any other symbol in the pattern is
considered as sign and compiled as such by the rule compiler.</li>
<li><em>hypothesis</em> is the hypothesis for the rule.</li>
<li>Optionally, <em>RHS-lisp-form</em> is one of possibly several right-hand
side actions.  Currently the only NClose specific RHS action is the
<code>(@SET *sign* *expression*)</code> operator used to assign a
value (<em>expression</em>) to a sign.  Other Lisp functions in a RHS action
are passed without modification to the Lisp evaluator.</li>
<li><em>string-documentation</em> is an optional textual description attached to
the rule.</li>
</ul>

<p>For instance the following are examples or well-formed, if
meaningful, rules:</p>

<pre class="example">
(add-to-kb (@LHS= (and (&gt; a 2) (string= foo &quot;hello&quot;))) (@hypo H3)
	(@RHS= (@set frob (* 2 a)) (@set boz &quot;test&quot;)) &quot;Another
comment&quot;)

(add-to-kb (@if (&gt; boz 0)) (@hypo H3))

(add-to-kb (@if (and (&gt; a c) (&lt; (* d 5) 10))) (@hypo H2)
	nil &quot;Commenting this H2 rule&quot;)
</pre>


<h3>Designing classes and objects</h3>

<p class="first">Still an area of research and experimental implementation work.</p>

<p>The introduction of a simple yet rich object system in Nexpert was the
major transition between the original version and the later Nexpert
Object.  This transition happened as early as 1986-87, at a time when
object-oriented programming languages were beginning to vie for
developers' attention and frame-based and object systems were still an
active area of AI research.</p>

<p>While object-oriented languages became mainstream, object systems
faded from the main AI research efforts only to find renewed attention
in so-called <em>middleware</em>, with COM/DCOM from Microsoft and the Object
Management Group's Corba/IIOP specifications being the major industry
beacons during the early nineties.  Although these were somewhat
superseded later on in the decade by the emergence of Web
protocols-based middleware using XML (SOAP/WSDL and the plethora of
WS- specifications) they played role model in the development of the
Web Services stack.</p>

<p>Today, with the Semantic Web initiative at the W3C&mdash;albeit making slow
progress in industry adoption&mdash;object systems are again under active
study and development.  The crux of the on-going Semantic Web matter
lies in the definition and use-cases of <em>ontologies</em>.  Proposals differ
on the expressivity of ontology specifications, on their actual
representation, and on their articulation with deductive systems of
various kinds&mdash;mostly based on first-order logic.  Two important
ontology systems in broad use today are the W3C-promoted RDF/OWL and
Topic Maps.  Another unrelated initiative, dubbed <em>microformats</em>, is
more interested in in-page data formatting for automated collection
and analysis.</p>

<h4>The NClosEmacs articulation between rule and object systems</h4>

<p class="first">The important innovation in the transition from Nexpert to Nexpert
Object was in the elegant articulation between the rule and the object
systems.  On the one hand the object system supported <em>classes</em>, defined
as collections of <em>properties</em>, and inheritance along two relations:
<em>subClassOf</em> and <em>instanceOf</em>, respectively from class to class(es) and
from class to object(s).  A third relation, from object to object(s),
defined as <em>partOf</em>, allowed two hierarchies (class to subclasses with
objects as leaves, and object to subobjects) to mingle in Nexpert
ontologies.</p>

<p>The system was designed as quite dynamic in nature and weakly
reinforced hierarchical relations, in contrast to object-oriented
programming languages&mdash;and more in par with the then AI-styled, and now
Semantic Web research.  Objects could sport additional properties to
the set of inherited ones; exceptions in default inheritance
mechanisms could be provided; objects could be moved from class to
class; objects could be created by rules' RHS actions, and so forth.</p>

<p>The articulation between rules and objects basically enabled LHS of
rules to query the object system for a set of subsets of objects
matching simple patterns and RHS to act upon this set of subsets.  The
syntax for expressing patterns was very compact and represented
classes as set of their instances, and objects as sets of their
subobjects with LHS patterns being either set operations such as
membership or intersections, or scalar typed tests on properties.</p>

<p>In the NClosEmacs proposed implementation we are trying to abstract
out simple design principles from the original ideas in Nexpert Object
to layer an object system over the NClose rule engine.</p>

<ul>
<li>The &quot;static&quot; part of the object system, the base ontology, should
minimally provide classes and objects with two hierarchical
relations (namely class/subclass and object/subobject, usually
specialization and mereological).  Inheritance mechanisms are
overlayed on the object system ontology.</li>
<li>The &quot;dynamic&quot; part of the object system, is the definition of the
query language (patterns) used in rules LHSes and the
object-related operations in the rules RHSes.</li>
</ul>

<p>Note that, in addition, the unification step should now collect set of
subsets of objects, or list of <em>scopes</em>, to be passed from the LHS to
the RHS.</p>

<p>In the vein of contemporary systems we are interested in using
NClosEmacs knowledge-based applications on modern ontology
representations.  So we plan again to separate concerns and provide
for different ontology representations together with an abstract API
for user-defined ontology representations&mdash;which may be required for
domain-specific applications, e.g. health/medicine applications.</p>

<p>In NCLosEmacs the interchangeable ontology modules are called <em>nclos</em>
for NClosEmacs Ontology/Object System.</p>

<p>NClosEmacs comes with three ontology modules:</p>

<ul>
<li>A default ontology with no inheritance which relies heavily on the
underlying Lisp evaluator and specifically on atom property lists,
@xref{The Default Object System in NClosEmacs}</li>
<li>An ontology representation based on <a href="http://www.w3.org/TR/owl-features/">OWL-Lite</a> where classes and
objects are described using the OWL-Lite conventions,
@xref{The OWL-Lite Object System in NClosEmacs}</li>
<li>An ontology representation based on <a href="http://www.topicmaps.org">Topic Maps</a> where classes and
objects of NClosEmacs are represented as such.</li>
</ul>

<p>Both OWL-Lite and XTM (Topic Maps) ontology representations offer a
much more expressive environment for ontologies than the original
Nexpert Object object system.  The current implementation is only a
basis for further research work inasmuch as the minimal feature set
for NClosEmacs was imported from OWL-Lite and Topic Maps.
Augmenting the pattern/action language to leverage their additional
expressive power constitute an open area for further research.  (The
implementation could use Emacs advising functions, for instance.)</p>


<h4>The Default Object System in NClosEmacs</h4>

<p class="first">The default object system in NClosEmacs uses the underlying ELisp
variables and evaluator to represent, store and access
objects. Individual objects are ELisp variables, and their individual
properties and values are stored in the symbol's property list
itself. Classes are not distinguished from composite objects
(superobjects) in this default nclos; there is no inheritance or
derivation mechanism.  Classes are using lists as simple set
representations.</p>

<p>The default nclos is installed by invoking:</p>

<pre class="example">
(nclose-use-nclos nil)
</pre>
at the beginning of the knowledge base file.

<p>Note that by default the default nclos is installed the first time
NClosEmacs is loaded.  After the default nclos installation, classes
and objects are simply defined by the add-to-kb-sets statement in the
knowledge base:</p>

<pre class="example">
    (add-to-kb-sets 'Ca  '(O1 O2 O3))
    (add-to-kb-sets 'Cb  '(O4 O5))
</pre>

<p>These two statements define two classes, &quot;Ca&quot; and &quot;Cb&quot; respectively.
The first class has three instances, namely objects &quot;O1&quot;, &quot;O2&quot; and
&quot;O3&quot;.  The class Cb has two instances: objects &quot;O4&quot; and &quot;O5&quot;.</p>

<p>In the default nclos objects' properties do not require definitions as
the properties and the objects they attach to are actually derived
from the rule parsing phase.  As a consequence the simple ontology
model supported by the default nclos is a collection of sets, or
classes, of individual objects, with no inheritance but dynamical
property lists for each object.</p>

<h5>Writing Rules with Patterns in the default nclos</h5>

<p>With each nclos systems comes a set of specific LHS query operators
and a related set of RHS commands to be used in rules.  In addition to
matching LHS conditions, the inference engine is also required to
<em>unify</em> patterns and subsets of objects in the ontology.  A pattern in a
rule LHS can be seen as a query against to the ontology which returns
a, possibly empty, set of objects.  Hence the unification of a LHS not
only returns <em>true</em> or <em>nil</em> to indicate whether all of its conditions
are matched or not, but, in addition, a <em>result set</em> accumulating all the
subsets of objects that matched its patterns.</p>

<p>When the LHS is matched, this result set is passed to the rule RHS
where object-specific commands can operate upon these sets and their
individual object members.</p>

<p>In the default nclos there are basically two major patterns: <em>all</em> and
<em>some</em>, which query an individual class for all its instances matching a
given condition.  The general form of a pattern is:</p>

<pre class="example">
    (all-in 'CLASS-NAME INTEGER 'AND-OR-ELISP-FORM)
</pre>

<p>and</p>

<pre class="example">
    (some-in 'CLASS-NAME INTEGER 'AND-OR-ELISP-FORM)
</pre>

<p>The first pattern (<em>universal</em>) is true when all instances of the said
class match the lisp form passed as the last argument.  Its result set
is simply the list of instances of the said class.</p>

<p>The second pattern (<em>existence</em>) is true when some, i.e. at least one,
instances of the said class match the lisp form passed as the last
argument.  Its result set is the subset of this class instances that
actually matched the test lisp form.</p>

<p>Note the integer second argument passed in both patterns.  This is the
index of the subset in the rule global result set, on which the query
should be applied.  Several patterns in the same rule LHS may refer to
the same index; they then act as successive filters on the subset
resulting on previous pattern-matching queries on the same index.</p>

<p>In the third argument AND-OR-ELISP-FORM, each free ELisp variable is
considered a <em>property</em>, defined on all instances of the class passed as
the second argument.  These &quot;dynamic&quot; properties are created and added
to objects' representations on an as-needed basis, by adding them to
the ELisp variable symbol property list on the fly.</p>

<p>Let's look at a few examples.</p>

<pre class="example">
(add-to-kb-sets 'Ca  '(O1 O2 O3))
(add-to-kb-sets 'Cb  '(O4 O5))

(add-to-kb
 (@if (and (&gt; x 0)
	   (and (all-in 'Ca 1 '(or (&gt; p1 0) (&gt; p2 0)))
		(some-in 'Ca 1 '(&gt; p3 5)))))
 (@hypo H)
)
</pre>

<p>This knowledge base defines two classes, Ca and Cb, as before and adds
one rule with a LHS containing two patterns, the first one being an
universal pattern on class Ca and result set number 1, the second one
being an existence pattern, also on class Ca and result set number 1.</p>

<p>The ELisp free variables <em>p1</em> and <em>p2</em> appear in the first pattern, and <em>p3</em>
in the next one.  Hence these three properties may be attached
to instances of the the class Ca, namely objects <em>O1</em>, <em>O2</em>, and <em>O3</em>.  In
contrast the variable <em>x</em> is not bound in any pattern and hence not a
property of an individual object, simply a scalar&mdash;here
numeric&mdash;variable.</p>

<p>This example rule fires when:</p>

<ul>
<li>the variable <em>x</em> is positive, and</li>
<li>both (i) all instances of class Ca have either a positive <em>p2</em> or a
positive <em>p1</em>, and (ii) some of these same instances have a <em>p3</em>
greater than 5.</li>
</ul>

<p>The unification succeeds if these conditions are met and returns a
result set containing only one subset.  This unique subset is made of
all instances of Ca with a <em>p3</em> greater than 5, and, by construction,
either <em>p1</em> or <em>p2</em> positive.</p>

<p>For instance, let's suppose the ontology looks like the following
table:</p>

<table class="muse-table" border="2" cellpadding="5">
  <thead>
    <tr>
      <th>Ca</th>
      <th>O1</th>
      <th>O2</th>
      <th>O3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>p1</td>
      <td>12</td>
      <td>-5</td>
      <td>2</td>
    </tr>
    <tr>
      <td>p2</td>
      <td>5</td>
      <td>3</td>
      <td>-1</td>
    </tr>
    <tr>
      <td>p3</td>
      <td>6</td>
      <td>0</td>
      <td>12</td>
    </tr>
  </tbody>
</table>

<p>Provided <em>x</em> is positive, the first pattern is matched: all instances of
class Ca have either <em>p1</em> or <em>p2</em> positive.  Only objects <em>O1</em> and <em>O3</em>,
however, match the second pattern with <em>p3</em> greater than 5. Hence the
LHS is true and the result set is the set:</p>

<pre class="example">
((O1 O3))
</pre>

<p>for further use in the RHS, if any.</p>

<p>Now consider a slightly differently phrased rule:</p>

<pre class="example">
(add-to-kb
 (@if (and (&gt; x 0)
	   (and (all-in 'Ca 1 '(or (&gt; p1 0) (&gt; p2 0)))
		(some-in 'Ca 2 '(&gt; p3 5)))))
 (@hypo H)
)
</pre>

<p>Because the second pattern now mentions a different index than the
first one, the LHS is true of false under the same situation than the
previous one, but its result set now contains two subsets rather than
one.  The first one is the list of (all) instances of class Ca with
either a positive <em>p1</em> or a positive <em>p2</em>; the second one is the list of
instances with a <em>p3</em> greater than 5:</p>

<pre class="example">
((O1 O2 O3) (O1 O3))
</pre>

<p>These two subsets are indeed different as the following rule, slightly
edited again, shows:</p>

<pre class="example">
(add-to-kb
 (@if (and (&gt; x 0)
	   (and (some-in 'Ca 1 '(or (&gt; p1 0) (&gt; p2 0)))
		(some-in 'Ca 1 '(&gt; p3 5)))))
 (@hypo H)
)
</pre>

<p>We are back with a single result subset but now two existence patterns on
the same subset.  The LHS is now true only if among the instance of Ca
with either a positive <em>p1</em> or a positive <em>p2</em>, some also have a <em>p3</em>
greater than 5.  The two succesive patterns act as filters, selecting
a first subset of Ca's instances and refining this subset with the
next selection.  When the LHS is true the result set returns those
instances that passed both filters.</p>

<p>Suppose the ontology looks like this new table:</p>

<table class="muse-table" border="2" cellpadding="5">
  <thead>
    <tr>
      <th>Ca</th>
      <th>O1</th>
      <th>O2</th>
      <th>O3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>p1</td>
      <td>12</td>
      <td>-5</td>
      <td>-2</td>
    </tr>
    <tr>
      <td>p2</td>
      <td>5</td>
      <td>3</td>
      <td>-1</td>
    </tr>
    <tr>
      <td>p3</td>
      <td>6</td>
      <td>0</td>
      <td>12</td>
    </tr>
  </tbody>
</table>

<p>the result set of applying the later rule is:</p>

<pre class="example">
((01))
</pre>
while the former rule would fail, the LHS would be set to false and
the result set empty. (<em>Exercize: Why?</em>)

<p>If the rule had been written with a different index for the second
pattern, however:</p>

<pre class="example">
(add-to-kb
 (@if (and (&gt; x 0)
	   (and (some-in 'Ca 1 '(or (&gt; p1 0) (&gt; p2 0)))
		(some-in 'Ca 2 '(&gt; p3 5)))))
 (@hypo H)
)
</pre>
the result set for the later ontology table would contain two subsets:

<pre class="example">
((O1 O2) (O1 O3))
</pre>
(<em>Same exercize: Why?</em>)

<p>As a rule LHS can alternate as many universal and existence queries
over the same or different result subsets, a rule may express fairly
complex queries against the simple default nclos ontology.</p>



<h5>Writing Rules with RHSes in the Default Nclos</h5>

<p>As previously mentioned the unification result set is passed, when the
rule is fired, to the RHS which basically executes its sequence of
commands.</p>

<p>The syntax of the <code>@set</code> RHS command has been extended to
handle the results of the LHS unifications.  The familiar syntax is,
as a reminder:</p>

<pre class="example">
(@set VARIABLE SCALAR-VALUE)
(@set VARIABLE LISP-FORM)
</pre>
which respectively assign a value or a computed value to the said
variable.  (This assignment may in addition trigger the forward
chaining mechanism.)

<p>Two new forms of the set command are available with the default nclos:</p>

<pre class="example">
(@set (prop-in OBJECT-NAME PROPERTY-NAME) [ SCALAR-VALUE | LISP-FORM ])
(@set (member-in CLASS-NAME INTEGER PROPERTY-NAME)
                 [ SCALAR-VALUE | LISP-FORM ])
</pre>

<p>The first new form is used to assign a (computed) value to the
designated property of the said object. For instance:</p>

<pre class="example">
(@set (prop-in 'O1 'p3) 5)
</pre>
sets the value of the <em>p3</em> property of object <em>O1</em> to the integer 5.

<p>The second form is used to assign a (computed) value to the designated
property of all objects in the subset, characterized by the class and
index passed, in the LHS unification result set.</p>

<p>A rule with a RHS:</p>

<pre class="example">
(add-to-kb
 (@if (and (&gt; x 0)
	   (and (some-in 'Ca 1 '(or (&gt; p1 0) (&gt; p2 0)))
		(some-in 'Ca 1 '(&gt; p3 5)))))
 (@hypo H)
 (@then
	(@set y (+ x 1))
	(@set (prop-in 'O3 'p4) (* 2 x))
	(@set (member-in 'Ca 1 'p4) y)
 )
)
</pre>
working against the simple aforementioned ontology:

<table class="muse-table" border="2" cellpadding="5">
  <thead>
    <tr>
      <th>Ca</th>
      <th>O1</th>
      <th>O2</th>
      <th>O3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>p1</td>
      <td>12</td>
      <td>-5</td>
      <td>-2</td>
    </tr>
    <tr>
      <td>p2</td>
      <td>5</td>
      <td>3</td>
      <td>-1</td>
    </tr>
    <tr>
      <td>p3</td>
      <td>6</td>
      <td>0</td>
      <td>12</td>
    </tr>
  </tbody>
</table>

<p>would evaluate its LHS to true, fire, execute the RHS side-effects
resulting in a final ontology modified as follows:</p>

<table class="muse-table" border="2" cellpadding="5">
  <thead>
    <tr>
      <th>Ca</th>
      <th>O1</th>
      <th>O2</th>
      <th>O3</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>p1</td>
      <td>12</td>
      <td>-5</td>
      <td>-2</td>
    </tr>
    <tr>
      <td>p2</td>
      <td>5</td>
      <td>3</td>
      <td>-1</td>
    </tr>
    <tr>
      <td>p3</td>
      <td>6</td>
      <td>0</td>
      <td>12</td>
    </tr>
    <tr>
      <td>p4</td>
      <td>x+1</td>
      <td></td>
      <td>2*x</td>
    </tr>
  </tbody>
</table>

<p>(<em>Final exercize: Why?</em>)  Note that <em>O2</em> has no assigned <em>p4</em> property after
the rule fires.  This is because <em>O2</em> is filtered out by all patterns in
the LHS and not explictly mentioned in the RHS: it never &quot;meets&quot; the
<em>p4</em> property.</p>

<p>Remark: In the current implementation the new set assignment commands
do not trigger any form of forward chaining.  This is an interesting
avenue of research as there are several levels of granularity
available for doing so: object level and class level namely.</p>



<h4>The OWL-Lite Object System in NClosEmacs</h4>

<p class="first">The OWL-Lite nclos uses definitions and conventions from the OWL Lite
specifications for representing ontologies.  In this nclos, complete
ontologies contain classes, objects, properties and slots.  In
contrast to the default nclos, the OWL-Lite nclos supports inheritance
from class to subclasses.</p>

<h5>Classes in the OWL-Lite nclos</h5>

<p>A class defines a group of individuals that belong together because
they share some properties. For example, Deborah and Frank are both
members of the class Person. Classes can be organized in a
specialization hierarchy using subClassOf. There is a built-in most
general class named Thing that is the class of all individuals and is
a superclass of all OWL classes. There is also a built-in most
specific class named Nothing that is the class that has no instances
and a subclass of all OWL classes.</p>

<p>Within an ontology, a class is defined by the following statement:</p>

<pre class="example">
(owl-class! 'Cb 'Ca)
</pre>
which defines the class <code>Cb</code> as a subclass of class
<code>Ca</code>.  By convention the rule of all classes in the
OWL-Lite nclos is called <code>'Thing</code> and must be stated in
every ontology as:

<pre class="example">
(owl-class! 'Thing nil) ;; Required
</pre>

<p>The graph of all classes is thus a tree rooted in &quot;Thing&quot;.</p>


<h5>Objects in the OWL-Lite nclos</h5>

<p>In addition to classes, we want to be able to describe their object
members. We normally think of these as individuals in our universe of
things. An individual is (minimally) introduced by declaring it to be a
member of a class.</p>

<p>The declaration statement for an individual in the OWL-Lite nclos is:</p>

<pre class="example">
(owl-individual! 'Obj1 'Cb)
</pre>
which declares a new individual, <code>Obj1</code>, as a member of the
class <code>Cb</code>.


<h5>Properties in the OWL-Lite nclos</h5>

<p>This is probably the place where differences with the default nclos
are the most important.  In the OWL-Lite nclos, properties are
first-class ontology elements and they are described and stated
outside of class and individual declarations.</p>

<p>A domain of a property limits the individuals to which the property
can be applied. If a property relates an individual to another
individual, and the property has a class as one of its domains, then
the individual must belong to the class. For example, the property
hasChild may be stated to have the domain of Mammal. From this a
reasoner can deduce that if Frank hasChild Anna, then Frank must be a
Mammal. Note that rdfs:domain is called a global restriction since the
restriction is stated on the property and not just on the property
when it is associated with a particular class.</p>

<p>The range of a property limits the individuals that the property may
have as its value. If a property relates an individual to another
individual, and the property has a class as its range, then the other
individual must belong to the range class. For example, the property
hasChild may be stated to have the range of Mammal. From this a
reasoner can deduce that if Louise is related to Deborah by the
hasChild property, (i.e., Deborah is the child of Louise), then
Deborah is a Mammal. Range is also a global restriction as is domain
above.</p>

<p>Hence the declaration of a property states its name, domain and range.</p>

<pre class="example">
(owl-property! 'p1 'Ca 'Thing)
</pre>
The previous statements declares the property <code>p1</code>, with
its domain being all instances of the class <code>Ca</code> and its
range any instance of the root class &quot;Thing&quot;.  This states that any
individual of class &quot;Ca&quot; may have a property &quot;p1&quot; which value is any
individual&mdash;as all individuals are instances of the root class.

<p>If the property's value is a basic type (number, string)
rather than an individual, its range should be defined as
<code>'Thing</code> anyway.  The OWL-Lite nclos provides a special
construct, called a <em>scalar</em>, to handle basic types.</p>

<p>In the current first stage of the implementation of NClosEmacs, all
properties ranges are considered scalar.</p>


<h5>Slots in the OWL-Lite nclos</h5>

<p>Slots in an OWL-Lite ontology are &quot;concrete&quot; properties.  A slot,
which has an individual id, associates a property with a specific
domain individual and a specific range value. For instance,</p>

<pre class="example">
(owl-slot! 'mySlotId 'p1 'Obj1 (owl-scalar! 5))
</pre>
assigns the value 5 to the property <code>p1</code> of the individual
<code>Obj1</code>.


<h5>Ontologies in the OWL-Lite nclos</h5>

<p>A complete ontology is then constituted of four lists: classes,
individuals, properties and slots.  In the OWL-Lite nclos, such an
ontology is defined and asserted with the following statement:</p>

<pre class="example">
(nclose-use-nclos ':OWL-LITE
  (onto! 'owl-bench1
	 ;; Classes
	 (list
	  (owl-class! 'Thing nil) ;; Required
	  (owl-class! 'Ca 'Thing)
	  (owl-class! 'Cc 'Cb)
	  (owl-class! 'Cd 'Thing)
	  (owl-class! 'Cb 'Ca)
	  (owl-class! 'Ce 'Cd)
	  (owl-class! 'Cf 'Cd)
	  )
	 ;; Individuals
	 (list
	  (owl-individual! 'Obj1 'Cc)
	  (owl-individual! 'Obj2 'Cf)
	  (owl-individual! 'Obj3 'Cd)
	  )
	 ;; Properties
	 (list
	  (owl-property! 'p1 'Ca 'Thing)
	  (owl-property! 'p2 'Ca 'Thing)
	  (owl-property! 'p3 'Ca 'Thing)
	  )
	 ;; Slots
	 nil
	 )
)
</pre>
The function <code>nclose-use-nclos</code> is now used to install an
OWL-Lite ontology&mdash;rather than the default nclos, in which case its
first argument is <code>nil</code>.

<p>The ontology itself is defined within the <code>onto!</code> statement
by its name followed by the four lists of classes, individual,
properties and slots.  In this specific example no slots are defined
in the ontology.  (Slots, however, may be defined dynamically during
the inference when, for instance, questions are asked interactively.)</p>


<h5>Writing rules for the OWL-Lite nclos</h5>

<p>The result of the independence between the rule and the object system
in the NCLosEmacs design is that rules are written the same way
whether for the default nclos or the OWL-Lite nclos.
@xref{Writing Rules with Patterns in the default nclos}, and @xref{Writing Rules with RHSes in the Default Nclos}.</p>

<p>The scope of the LHS operators is expanded in the OWL-Lite nclos as it
supports inheritance. Hence the <code>all-in, some-in, oone-in,
none-in</code> patterns now select all instances of the mentioned
class <em>and</em> of all its subclasses recursively.</p>



<h4>The Topic Maps Object System in NClosEmacs</h4>

<p class="first">In the current version the XTM ontology representation is not yet
available.</p>


<h4>Examining Objects and Classes</h4>

<p class="first">The current implementation provides two interactive commands for
printing the current state of the ontology.</p>

<dl>
<dt><strong>nclose-print-instances</strong></dt><dd>
This command prints at the insertion point all individual instances
of the selected class, and its descendant subclasses if the currently
installed nclos supports inheritance.</dd>

<dt><strong>nclose-print-object</strong></dt><dd>
This command prints at the insertion point all the properties and
their values for the selected object.</dd>
</dl>

<p>Later implementations should provide a proper class/object navigator.</p>




<h2>Running a session</h2>

<p class="first">The first step is to load the NClosEmacs engine (from Emacs) by
issuing the command <code>M-x load-file nclose.el</code>.  This
basically loads the core engine and initializes it for the current
Emacs session.</p>

<p>The preferred way to run an expert session in NClose is to open the
rule base text in a new Emacs buffer and evaluate its content with the
usual interactive Lisp command <code>M-x eval-current-buffer</code>.
This command compiles the rule base and sets up the rule interpreter
for a new session.</p>

<p>A complete expert system session is usually a three-step affair once
the appropriate rule base has been loaded.  There is an initial
volunteering/suggesting phase where the user is expected to either
volunteer some initially known data or focus on one or several
hypotheses of interest (or both).  The rule interpreter is actually
started with the interactive <em>knowcess</em> command which triggers
interactive evaluation of relevant rules.  Once this second phase
terminates, log traces and various data exploratory commands are
provided to investigate answers and results reached by the inference
engine.  Other commands are available to restart a session or to
reinitialize the engine altogether.</p>

<h3>Interactive volunteering and suggesting</h3>

<p class="first">@dfn{Suggesting} is the process through which an
hypothesis is posted on the agenda for evaluation.  The rule
interpreter evaluates an hypothesis by collection all rules leading to
the selected hypothesis and evaluating them in a backward-chaining
mode.</p>

<p>Note that, in contrast to rules engines like RETE, all rules sharing
the same hypothesis are evaluated and implicitly or-ed to find the
boolean value of the said hypothesis.  In the default implementation
the order in which these rules are evaluated is left undefined.  Of
course, the backward-chaining evaluation function could be advised
should a specific sequencing of the rules or a lazy evaluation be
required for a particular domain application.</p>

<dl>
<dt><strong>nclose-suggest</strong></dt><dd>
This function is invoked with <code>M-x nclose-suggest</code> to
suggest an hypothesis.  It works with the Emacs completion mechanism
so that the usual <code>? TAB SPC</code> special characters may be
used to select the hypothesis to suggest.</dd>
</dl>

<p>@dfn{Volunteering} is the process through with a
known piece of data is volunteered to the NClose engine, usually
before running an interactive session.</p>

<dl>
<dt><strong>nclose-volunteer</strong></dt><dd>
This function is invoked with <code>M-x nclose-volunteer</code> to
volunteer the value of a sign.  The user is prompted for the sign
first (with standard Emacs completion available) and then for the
value.</dd>
</dl>

<p>Several suggest and volunteer commands may be issued before running a
session to provide initial information to the expert system.</p>


<h3>Knowcessing restarting and reinitializing sessions</h3>

<p class="first">@dfn{Knowcessing} a contraction of <em>knowledge
processing</em> denotes the process of running an interactive expert system
session with NClosEmacs.  Once the initial suggest and volunteer phase
is completed, the rule interpreter is started with the
<code>knowcess</code> command.  User interactions happen in the
mini-buffer as the inference process might need to prompt the user for
information.</p>

<dl>
<dt><strong>nclose-knowcess</strong></dt><dd>
This interactive command invoked with <code>M-x
nclose-knowcess</code> without argument.</dd>
</dl>

<p>When a question is asked to the user, interactions happen in the
mini-buffer; the session may be aborted by typing <code>C-g</code>.</p>

<p>The expert system session may be restarted at the end of the knowcess
phase with the following command:</p>

<dl>
<dt><strong>nclose-reset-session</strong></dt><dd>
This interactive command invoked with <code>M-x nclose-reset-session</code>
restarts the expert system session, setting all signs back to unknown
status and emtying the agenda.</dd>

<dt><strong>nclose-reset-globales</strong></dt><dd>
This interactive command invoked with
<code>M-x nclose-reset-globales</code> without arguments
reinitializes the rules engine.  In particular, all currently loaded
rule bases are deleted from the production memory.</dd>
</dl>

<p>There is also a less frequently used function:</p>

<dl>
<dt><strong>nclose-reset-signs</strong></dt><dd>
This interactive command invoked with <code>M-x
nclose-reset-signs</code> unbinds all previously known signs.</dd>
</dl>


<h3>Encyclopaedia</h3>

<p class="first">The current implementation provides only a few functions to
pretty-print the list of signs and hypotheses with their values.
Gathered under the exaggerated headline of &quot;Encyclopaedia&quot; these
functions are as follows:</p>

<dl>
<dt><strong>nclose-print-wm</strong></dt><dd>
This interactive command which is invoked with <code>M-x
nclose-print-wm</code> inserts a table of signs and their values at
the cursor position.</dd>

<dt><strong>nclose-print-hypos</strong></dt><dd>
This interactive command which is invoked with <code>M-x
nclose-print-wm</code> inserts a table of hypotheses and their values at
the cursor position.</dd>
</dl>


<h3>Session logs</h3>

<p class="first">A complete session log is maintained in a special Emacs buffer named
<code>*nclose-log*</code>.  This buffer keeps track of the inference
progress from the initial knowcess command.  The buffer is erased with
each reset session command issued by the user.</p>

<p>Note that logging is implemented as a specific aspect layer in the
<code>advice.el</code> file, @xref{Aspect Oriented Programming}.  It is then easy to switch logging on or off by
simply enabling or disabling this particular layer in the file.  In
addition, more detailed levels of trace are simply implemented by
creating new advising functions for events of interest in this layer.</p>



<h2>Implementation</h2>

<p class="first">This section describes in more detail some of the features in the
current implementation of NClose basic operations.</p>

<p>The implementation of NClosEmacs relies on the underlying ELisp
interpreter in Emacs.  The primary design choice was to represent each
sign and hypothesis in rules as Lisp symbols, the value of which would
be the value referred to or inferred by the expert system.</p>

<p>As a consequence of this choice, rules are Lisp macro forms which call
internal functions managing a few global (to the ELisp environment)
variables used by the rule interpreter.  Note that as signs are Lisp
variables, they are available in the ELisp environment available with
each Emacs session.  In other words, the inference engine and the
loaded rule base(s) are indeed available whatever the buffer displayed
in Emacs provided they were initialized and loaded in the same
session.</p>

<p>As a reminder, NClosEmacs is made available to the current Emacs
session by loading the <code>nclose.el</code> file with the standard
command <code>M-x load-file</code>; a rule base is loaded for
interpretation by the NClosEmacs engine by opening a buffer on the
rule base file (<code>C-x C-f</code> or <code>C-x C-v</code>, for
instance) and evaluating the buffer with the standard interactive
command <code>M-x eval-current-buffer</code> in Emacs.</p>

<p>The interpreter relies on a global agenda, a first-in first-out stack
of hypotheses to evaluate.  Gating, which is enabled by default, is
responsible for posting hypotheses on the agenda as the inference
progresses.  (Further research might in fact unveil other inference
coprocesses that would interact with the agenda during an expert
system session.)  The essential interpreter process pops out the next
hypothesis from the agenda, stopping it it is empty, and passes it to
the evaluator.</p>

<p>The evaluator implements a simple backward-chaining mode.  Rules
leading to the hypothesis are first collected from production memory.
All are in turn evaluated by attempting to pass their LHSes to the
ELisp evaluator (the <code>eval</code> function).  On a failure to
evaluate due to an unbound symbol, which in the chosen representation
stands for an unknown sign, a question is asked to the user and
evaluation is retried until it is successful.  Individual rules
evaluations are implicitly or-ed to assign a boolean value to the
hypothesis, triggering the corresponding RHSes if present.</p>

<p>As previously mentioned, this implementation is also intended as a
base for further research.  A promising direction is to look into
advising each of the previous evaluation steps to evolve
domain-specific inference engines for vertical applications, while
keeping the general architecture and rules syntax of NClosEmacs.
Another direction of research is to investigate attachment of other
cognitive coprocesses to the inference itself, again using advising
functions in system-specific layers.  (Machine Learning and DDB/TMS
being prime candidates for inference coprocesses in the NCLose
architecture.)</p>

<p>Finally NCloseEmacs runs in the Emacs universe.  It is only natural
that it should come with a rudimentary, at this stage, major mode for
authoring and running rule bases.  The current implementation, which
uses the generic mode approach, is only a first look into that
development.</p>

<h3>Rules compilation</h3>

<p class="first">An introductory word about the basic data structures in this
implementation of NClosEmacs.</p>

<p>In this version, the four global variables required for the
interpreter are simply implemented as lists.</p>

<ul>
<li>nclose-global-signs is the list of signs collected by &quot;compiling&quot;
the rules</li>
<li>nclose-global-hypos is the list of hypotheses kept in a separate
list; note that an hypothesis might be a sign if it is mentioned in
another rule's LHS (the <code>Yes</code> and <code>No</code>
operators operate on hypotheses as well as on boolean signs).</li>
<li>nclose-global-pm is the list of rules currently loaded</li>
<li>nclose-global-agenda is the agenda, also implemented as list.</li>
</ul>

<p>Other global variables are possibly added by advising functions as
required for the operation of their layer.  This is in fact the case
for the gating and logging layers.</p>

<p>ELisp offers several alternatives to list for the implementation of
the global interpreter variables: hash-lists, sequences, property
lists and association lists are valid candidates for alternative
implementations.  Furthermore, several extension packages exist for
ELisp and Emacs to integrate with external repositories such as
relational databases, file systems or remote servers.  These could be
explored in further research work.</p>


<h3>Agenda Driven Evaluation</h3>

<p class="first">The agenda keeps track of hypotheses to evaluate.  The initial
hypotheses are posted through the suggest command and, indirectly, by
the initial volunteer command.  Other hypotheses may be posted during
the inference process.</p>

<p>However, when the evaluation of a rule finds a yet unbound hypothesis, it
starts evaluating that hypothesis at once, without posting it to the
agenda.</p>


<h3>Classes and Objects</h3>

<p class="first">This section is a first draft.  It covers the basics of the default
and the OWL-Lite nclos.</p>

<h4>Introducing ontologies in NClosEmacs</h4>

<p class="first">Objects and classes were introduced in Nexpert Object as early as
1986.  The design of the original class and object system reflected
the early thinking on object systems which was barely emerging at the
times.  Partly inspired from object-oriented programming languages
such as Samlltalk and C++, partly from frame-based and AI research
object systems, it distinctly had a set-theoretic flavor.  Patterns
expressed subset selections from classes or subobject selections from
objects following a classical element/set distinction.  On the other
hand, Nexpert Object supported a fairly rich inheritance system with
overriding, pre- and post- method executions, exception handling and
dynamic object attachment/detachment.</p>

<p>In the current NClosEmacs incarnation, we chose to leverage progresses
made since then in formalizing the notion of <em>ontology</em> which now sits
at the core of the Semantic Web iniative.  More specifically a nclos
is based on a particular specification of an ontology.  The default
nclos, for instance, has a simple ontology specification : classes are
considered as sets of objects, each having a series of scalar
properties, with no inheritance and no complex property types.  The
OWL-Lite nclos, on the other hand has a much more comprehensive class,
object and property representation, with inheritance and complex types
&mdash; although currently the LHS pattern language and the RHS commands
have not yet been extended to benefit from the enriched types.  The
common ground for the formal definition of ontologies in NClosEmacs is
a structure made of:</p>

<ul>
<li>a list of classes each uniquely identified by a name or id, each
class may be attached to a parent class or to the root class (by
convention <code>Thing</code>).</li>
<li>a list of objects each uniquely identified by a name or id and
attached to a parent class.</li>
<li>a list of properties, also uniquely identified by a name or an id,
each with a scope &mdash; which is the class which instances it attaches
to &mdash; and a range &mdash; which is the &quot;type&quot;, a class name which
instances the property's value is permitted to take.</li>
<li>a list of slots, each one attaching a value to a property for a
given object.</li>
</ul>

<p>In addition each ontology has a unique name. (In the current
implementation only one such ontology may be installed.  Future
releases may offer better ontology packages handling.)</p>

<p>This simple ontology specification is provided in the
<code>ontology.el</code> file.  This file contains the basic
<code>onto-defstruct</code> ELisp macro which can be used by ontology
models to instantiates the class, object, property and slot persistent
records they need.</p>

<p>For instance, the OWL-Lite nclos defines its classes as:</p>

<pre class="example">
(onto-defstruct owl-class ((:finder . id)) id subClassOf)
</pre>
which specifies that a class in the OWL-Lite nclos has an id, which is
unique and searchable for in the persistent store, and a
<code>subClassOf</code> which contains the id of the parent class.
With this ontology specification &mdash; in this case defined as expected
in the <code>owl-lite.el</code> file &mdash; concrete OWL-Lite classes in a
knowledge base are declared with ELisp forms like:

<pre class="example">
	      (owl-class! 'Thing nil)    ;; This is required
	      (owl-class! 'Winery 'Thing)
	      (owl-class! 'Region 'Thing)
	      (owl-class! 'ConsumableThing 'Thing)
	      (owl-class! 'Glen 'Winery)
</pre>
These declarations have side-effects and create automatically getters
and setters, testers and finders for their classes:

<dl>
<dt><strong>owl-class?</strong></dt><dd>
Returns true if its argument is an <code>owl-class!</code> form.</dd>

<dt><strong>owl-class-id</strong></dt><dd>
Getter for the <code>id</code> name property of the class argument.</dd>

<dt><strong>update-owl-class-id</strong></dt><dd>
Setter for the <code>id</code> name property of the class
argument. It is also associated to setf, so that the invocation
<code>(setf (owl-class-id class) 'New-Name)</code> works as expected.</dd>

<dt><strong>owl-class-subClassOf</strong></dt><dd>
Similar definition for setter as above.</dd>

<dt><strong>update-owl-class-subClassOf</strong></dt><dd>
Similar definition for setter as above.</dd>

<dt><strong>onto-find-owl-class id list-of-classes</strong></dt><dd>
This function performs a basic search on the <code>id</code> of a
class, returning the <code>(owl-class! ...)</code> that matches, if
any, in the list passed as the second argument.</dd>
</dl>

<p>These functions are used in the implementation of the adaptation of
the pattern language to the nclos in point.  They may be used by
programmers to extend the ontology services in NClosEmacs as well.</p>

<p>All elements in an ontology model use the <code>onto-defstruct</code>
construct for their basic building blocks. @xref{Adding new
object systems}</p>


<h4>Persistence and Volume</h4>

<p class="first">Issues of persistence and volumes are not addressed in the current
implementation of nclos models.  Complete ontologies are kept in
memory as ELisp lists.</p>


<h4>Variables versus Slots</h4>

<p class="first">In the current implementation they are two types of scalar &mdash; basic
type &mdash; variables.  System-wide variables such as <code>X</code> in
the following LHS fragement:</p>

<pre class="example">
(&gt; X 3)
</pre>
and slots, the value of which is also of a basic type, such as
<code>p3</code> in:

<pre class="example">
(some-in 'Class-A 2 (&gt; p3 3))
</pre>

<p>In the original Nexpert Object, system-wide variable were
automatically updated to object type with special property
<code>value</code>, so that the first condition would read:</p>

<pre class="example">
(&gt; (prop-in 'X 'value) 3)
</pre>

<p>Another option with the current implementation would be to consider
system-wide variables as local slots of a <code>System</code> object,
so that the former LHS fragment would in fact read:</p>

<pre class="example">
(&gt; (prop-in 'System 'X) 3)
</pre>
with the same effect.

<p>The current implementation maintains separate ELisp variables for each
at this stage.  This precludes, for now, the use of system-wide
variables within the third argument expression of a pattern operator
such as all-in, some-in, and so forth.</p>


<h4>Overview of the nclos API</h4>

<p class="first">The articulation between the rule engine and the ontology management
is defined in the <code>nclos.el</code> file which specifies a set of
ontology related functions required by the engine for evaluation,
selection and execution of rules.  The most important are:</p>

<dl>
<dt><strong>nclos-slot-reader sym prop</strong></dt><dd></dd>
<dt><strong>nclos-slot-writer sym prop value</strong></dt><dd>
These are the getter and setter for a slot value, which is identified
by its object and its property.</dd>

<dt><strong>nclos-slot-reset</strong></dt><dd>
This function reinitializes the list of slots to the original
ontology definitions installed in the knowledge base.</dd>

<dt><strong>nclos-find-instances class</strong></dt><dd>
Retrieves a list of ids of all the instances of the passed class
(recursively if inheritance is supported in the current nclos).</dd>

<dt><strong>nclos-find slots obj</strong></dt><dd>
Enumerates conses of property id and value for slots attached to the
passed object.  This is mostly used for tracing and logging purposes.</dd>

<dt><strong>nclos-find-all-classes</strong></dt><dd></dd>
<dt><strong>nclos-find-all-objects</strong></dt><dd>
Returns as a list the store of classes or objects, accordingly.</dd>
</dl>

<p>When extending NClosEmacs with a new nclos model, these functions, and
other ancillary functions in the same file, have to be extended to
accommodate the new model.  This can be done either by adding proper
code into the <code>(cond ...)</code> forms or by using advising
functions.  In both cases the <code>globales.el</code> and the
<code>reset.el</code> might also require some alterations.</p>

<p>Usually the extensions of these functions make use of separate
model-specific files as is the case for instance for:</p>

<ul>
<li>Default nclos model.  Refers to the <code>set-unification.el</code> and
<code>set-instances.el</code> files.</li>
<li>OWL-LITE nclos model. Refers to the <code>owl-lite.el</code> and
<code>owl-instances.el</code> files which rely on the
<code>ontology.el</code> base.</li>
<li>EIEIO nclos model. Refers to the <code>nclos-eieio.el</code> file. @xref{Adding new object systems}</li>
</ul>

<p>In contrast to the current (redundant) implementation, this separation
would allow to on-demand loading of the required code for a given
nclos model at installation time.  This is not yet the case in this
first pass implementation where all models are indeed available all
the time.</p>



<h3>Adding new object systems</h3>

<p class="first">This section explains how to add a new object system to NClosEmacs.
More specifically, this section details how the <a href="cedet.sourceforge.net/info/eieio.html">EIEIO</a> object system,
part of the CEDET suite of tools for Emacs, may be added to NClosEmacs.</p>

<h4>Overview of classes and objects</h4>

<p class="first">This section highlights the features of classes and objects in EIEIO
which are relevant to the NClosEmacs rule system.</p>

<p>The class and object system in EIEIO draws its inspiration from the
<a href="http://www.ravenbrook.com/doc/2003/07/15/clos-fundamentals/">CLOS standard</a> in the early eighties.  Its architecture is different
from the modern &quot;ontology&quot; approach of the Semantic Web, best
exemplified in RDF and OWL.  Along the lines of the reference <em>The
Art of the MetaObject Protocol</em>, EIEIO provides classes, objects,
generic functions and methods.  The integration path discussed in this
chapter is only one way of articulating a NClos based on the ideas in
<em>The Art</em> but would basically work for other CLOS-inspired ELisp
implementations.  (See also <a href="http://lib.stat.cmu.edu/xlispstat/Src/other/closette/closette.lisp">Closette</a>.)</p>

<p>The integration proposed here is implemented in the
<code>nclos-eieio.el</code> file and supposes the EIEIO library to be
properly installed in the load-path of Emacs.  Its basic design
options are:</p>

<ul>
<li>Directly use classes and objects defined in EIEIO as classes and
objects in the NClose set-oriented perspective.</li>
<li>Similarly to the OWL implementation, define an &quot;ontology&quot;
abstraction; here simply to bundle classes and objects effectively
used in a rule base in a namespace.</li>
<li>Map as directly as possible EIEIO-provided inheritance mechanisms
to NClose inheritance requirements.</li>
</ul>

<p>These options simplify the integration work and reduce the amount of
code necessary to implement the NClos API to EIEIO.</p>


<h4>NClos class implementation</h4>

<p class="first">The minor departure from classes and objects as required in the NClose
inference engine and CLOS-inspired class/object system is the set
oriented perspective imposed by patterns in rules LHS (and set
commands in the RHSes).  Operators like `some-in' or `all-in' trigger
evaluation on all instances of said class as their side-effect is to
build the list of matching objects to be passed to the rule RHS.  The
classes used in the rule system hence are required to keep track of their
instances.  Fortunately, this is easily implemented in EIEIO via the
use of the special class <code>eieio-instance-tracker</code>, defined
in the extension <code>eieio-base</code> module.</p>

<p>Here we chose to define a new keyword <code>nclose-defclass</code> to
supersede the standard CLOS <code>defclass</code> form for those
classes which are used in a NClose knowledge base.  This specific
class definition form simply attach the defined class to the root
<code>eieio-instance-tracker</code> class rather than the default
one.  Its definition is simply:</p>

<pre class="example">
(defmacro nclose-defclass (name superclass fields &amp;rest options-and-doc)
  &quot;Defines a NClose class for use in the knowledge base.  These classes are otherwise normal EIEIO classes, with additional structure to integrate with the inference engine LHS patterns and RHS commands.&quot;
  `(eval-and-compile
     (defvar ,(util-s-cat name &quot;instances&quot;) nil)
     (eieio-defclass ',name
		     ;; Attach to a different metaclass
		     ',(append superclass (list 'eieio-instance-tracker))
		     ;; Add the required init forms for metaclass-inherited
		     ',(append fields
			       (list
				(list 'tracking-symbol
				      ':initform (util-s-cat name &quot;instances&quot;))))
		     ',options-and-doc)
       )
  )
</pre>

<p>Note that this form defines a global variable, called
<code>class-instances</code>, for each new class in order to track its
instances as they are created and deleted.  This global variable is
kept as the value of the <code>tracking-symbol</code> slot for each
class.</p>

<p>With this convention, the set of instances of a given class is simply:</p>

<pre class="example">
(defun nclos-eieio-instances (class)
  &quot;Returns a list of the class instances, one level deep.&quot;
  (symbol-value (util-s-cat class &quot;instances&quot;)))
</pre>

<p>The methods in class <code>eieio-instance-tracker</code> are
responsible for updating the tracking symbol at each instance creation
of deletion.</p>

<p>Finally the ontology abstration is a class defined as:</p>

<pre class="example">
;; Experimental representation syntax, inspired loosely from OWL-Lite.
(defclass eieio-ontology ()
  ((onto-id
    :initarg :id
    :documentation &quot;The unique name of the NClose class.&quot;
    )
   (onto-classes
    :initarg :classes
    :documentation &quot;The list of CLOS/EIEIO class names in the NClose namespace.&quot;
    )
   (onto-objects
    :initarg :individuals
    :documentation &quot;The list of CLOS/EIEIO object names in the Nclose namespace.&quot;
    )
   )
  :documentation &quot;The ontology (super)class.&quot;
)
</pre>

<p>This simplistic class keeps tracks of all classes and objects relating
to a knowledge base.  It could be enriched and extended towards a full
namespace management with ontology-level primitives and commands, for
instance.</p>

<p>Note that as NClose classes are indeed EIEIO classes, they may be
extended with generic functions and methods as for any other standard
class.</p>


<h4>NClos object and slot implementation</h4>

<p class="first">With the class implementation in place, NClose objects are none other
than EIEIO objects, instances of <code>nclose-defclass</code> defined
classes.  They are defined and used as would be any EIEIO standard
object.  As an example, here is a complete ontology form as declared
in a knowledge base file:</p>

<pre class="example">
(nclose-use-nclos
 ':EIEIO
 (eieio-ontology &quot;Test ontology&quot;
  :id &quot;Experimental ontology&quot;
  :classes (list
	    (nclose-defclass Ca ()
			     ((pressure :initarg :pressure
					:documentation &quot;Measure at T0&quot;)
			      (temperature :initarg :temperature
					    :documentaion &quot;Heat Excess&quot;)
			     (volume :initarg :volume))
			    &quot;Tank class&quot;)
	    (nclose-defclass Cb (Ca)
			    ((manufacturer :initarg :manufct)
			     )
			    &quot;Subtank with identified manufacturing origin&quot;)
	    (nclose-defclass Cc (Ca)
			    ((duration :initarg :duration)
			     )
			    &quot;Subtank with identified alert duration&quot;)
	   )
 :individuals (list
	       (Ca &quot;O1-name&quot; :pressure 200 :temperature 100 :volume 10)
	       (Ca &quot;O2-name&quot; :pressure 200 :temperature 200 :volume 20)
	       (Ca &quot;O3-name&quot; :pressure 200 :temperature 300 :volume 30)
	       (Cb &quot;O4-subtank&quot;
                   :manufct &quot;GE&quot;
                   :pressure 200 :temperature 100 :volume 10)
	       (Cc &quot;O5&quot;)
	       )
 )
)
</pre>

<p>This fragment shows an ontology with 3 classes, the first one being
parent to the next two, and 5 objects variously defined.</p>

<p>Note that, in contrast to Semantic Web inspired ontologies, slots are
not separately defined as first-class properties like in OWL-LITE.
Here the slots are implicitly defined in the class specificaiton and valued
in the object declarations themselves.</p>


<h4>Query functions</h4>

<p class="first">The get/set and query functions are the core of the NClos API
implementation.  Adding a new object system involves adding dispatch
calls in the <code>nclos.el</code> file to issue appropriate getter,
setter and query calls according to the installed nclos. (Which means,
in particular, that for a given knowledge base there is only one
currently installed nclos, namely the one resulting from the last
<code>nclose-use-nclos</code> call.)</p>

<p>For instance, the slot reader should look like:</p>

<pre class="example">
(defun nclos-slot-reader (sym prop)
  &quot;Get value of the slot identified by sym.prop, which may be unbound.&quot;
  (cond
   ((equal ':OWL-LITE nclose-global-nclos)
    (owl-property-reader sym prop)  ;; See `owl-instances.el'
    )
   ((equal ':EIEIO nclose-global-nclos)
    (eieio-property-reader sym prop) ;; See `nclos-eieio.el'
    )
   (t
    (let ((val (get sym prop)))
      (if val val
	(read-minibuffer (format &quot;What is the value of the %s of %s? &quot; prop sym)))))
   )
)
</pre>

<p>and similarly for the other dispatch functions.</p>

<h5>Reading and Writing Slot Values</h5>

<p>With the previous design options in place, the getter and setter code
for EIEIO is as follows:</p>

<pre class="example">
(defun eieio-property-reader (sym prop)
  &quot;Reads in the scalar value of `prop' in object `sym' in the current EIEIO ontology.&quot;
  (if (slot-boundp sym prop)
      (slot-value sym prop)
    (read-minibuffer (format &quot;What is the value of %s of %s? &quot; prop (object-name sym)))
    )
  )

(defun eieio-property-writer (sym prop val)
  &quot;Writes value `val' to `prop' in object `sym'.&quot;
  (set-slot-value sym prop val)
  )
</pre>

<p>Note that these functions may be advised, if required, to implement
additional inference mechanisms such as gating or context associations
on individual slots or objects. (In the current implementation,
though, it is not the case.)</p>


<h5>Querying the Ontology</h5>

<p>Query functions are required for the encyclopedia commands to output
class and object descriptions.  They are also useful to implement
browsers and other visual representation of the knowledge base.  The
basic query functions defined in the NClos API are:</p>

<ul>
<li><code>nclos-scope-acc</code> used in LHS unification to create a
list of all instances of a given list of classes</li>
<li><code>nclos-find-instances</code> to provide a list of all objects
in passed class argument</li>
<li><code>nclos-find-all-classes</code> to list all NClose defined
classes in the knowledge base</li>
<li><code>nclos-find-all-objects</code> to list all NClose objects in
the knowledge base, independently of their class attachment</li>
<li><code>nclos-find-slots</code> which returns a list of consed slot
value pairs for a given object (or object name) argument.</li>
</ul>

<p>As NClose inheritance abstraction specifies that instances of
subclasses are also instances of their superclasses, the firs step is
to implement a recursive exploration of the class inheritance tree to
produce all instances of a given class.  This is what the
<code>nclos-eieieo-all-instances</code> function does in a
NClos-dependent way.</p>

<p>An example implementation of the unification initialization primitive
for EIEIO classes:</p>

<pre class="example">
;; Tail recursive implementation of initial extensions environment
(defun eieio-scope-acc (specs env)
  &quot;Initializes the initial extensions for rules evaluation in EIEIO.&quot;
  (cond
   ((null specs) env)
   (t
    (let ((ext (map-append
		(nclos-eieio-all-instances (extract-class (car specs)))))
	    )
	(put env (extract-class (car specs)) (make-vector (cdar specs) ext)))
    (eieio-scope-acc (cdr specs) env)
    )
   )
  )
</pre>

<p>The result is provided as the symbol plist for `env' which lists, for
each class mentioned in a rule LHS, the initial list of its instances,
called the <em>scope</em>.  As unification proceeds, the scope is further
reduced by filtering it out according to the LHS patterns.  The final
scopes are passed to the RHS, when all conditions are matched.</p>

<p>The remaining query functions are somewhat simpler as they rely on
calling to the global ontology currently installed, an instance of the
<code>eieieo-ontology</code> class.</p>

<pre class="example">
(defun eieio-find-all-classes (onto)
  &quot;List all class symbols defined in current ontology.&quot;
  (mapcar '(lambda (class-spec) (elt class-spec 1)) (slot-value onto :classes))
  )

(defun eieio-find-all-objects (onto)
  &quot;List all individual names (objects) defined in ontology.&quot;
  (mapcar 'object-name (slot-value onto :individuals))
  )
</pre>

<p>Finding instances of a class is done as follows:</p>

<pre class="example">
(defun eieio-find-instances (class)
  &quot;List all instances (recursively) of an EIEIO class. `class' is a symbol.&quot;
  (mapcar 'object-name (map-append (nclos-eieio-all-instances class)))
  )
</pre>

<p>Note that the string-typed names of objects are returned here rather
than their raw vector symbol representation in EIEIO.</p>

<p>Similarly for slots of a given object:</p>

<pre class="example">
(defun eieio-find-slots (objname)
  &quot;List conses of prop . values for slots of `obj'&quot;
  (let ((obj (find-object objname nclose-global-ontology))
	)
    (mapcar '(lambda (x) (cons x (slot-value obj x))) (object-slots obj))
    )
  )
</pre>

<p>Note that the argument here is the name of the object, as a string,
rather than the object symbol itself, hence the
<code>find-object</code> query against the ontology.</p>



<h4>Packaging for the NClosEmacs library</h4>

<p class="first">The suggested packaging for adding a new nclos system to NClosEmacs is
to use the `provide/require' facilities for ELisp.  The NClos API
implementation would usually <code>require</code> the class/object
library and <code>(provide 'nclos-class-object-library)</code> to
NClosEmacs.  The following steps are usually required:</p>

<ul>
<li>Implement the NClos API for the selected class/object library and
use provide/require</li>
<li>Edit the mamefile to trigger compilation of the previous
implementation</li>
<li>Edit <code>nclos.el</code> to appropriately dispatch calls to your
library</li>
<li>If required, add specific keywords and commands to the NClose major
mode in <code>nclose-mode.el</code></li>
<li>Finally make sure the class/object library is in the load-path
specified in the `makefile', with the make variable <code>LOADPATH</code></li>
</ul>

<p>The library is rebuilt by issuing the <code>make release</code>
command within the NClosEmacs directory.</p>


<h4>On the EIEIO nclos</h4>

<p class="first">The `SATFAULT' directory in the release contains a revived antique
example of knowledge base which was consistently used in
demonstrations.  The `SATFAULT' knowledge base is provided in two
forms, one with an OWL-LITE ontology, the other with an EIEIO
implementation of the same ontology.</p>

<p>In this EIEIO experimental implementation, the release benefits from
the tree visualization in the <code>tree.el</code> file.  This
EIEIO-specific features provides a basis for a simple <em>ontology browser</em>
implementation.  This simple browser is invoked through the
interactive command `nclose-browse-class'.</p>

<p>For a given class, the browser shows the tree of its subclasses.  With
the cursor positioned on the name of a class in the browser, several
keyboard commands become available:</p>

<ul>
<li>`e' shows the documentation for the class, including its slots;</li>
<li>`x' lists the instances of the class</li>
</ul>

<p>(Additional commands will become abailable in further releases.)</p>




<h3>Aspects</h3>

<p class="first">As a practical research matter, this implementation looks at aspects
to support some of the NClose behaviors.  In the current version of
NClosEmacs, AOP has been investigated to develop so-called inference
@dfn{coprocesses}, additional computing processes
that occur while inference is progressing.  The coprocesses we have in
mind range from simple logging of user actions and inference engine
deductions to complex machine learning algorithms or truth maintenance
systems.  In the current release we have experimented with using
aspects, or to be more specific context-oriented programming, for the
NClose gating mechanism and for logging.</p>

<h4>The Gating Aspect Layer</h4>

<p class="first">Gating is somewhat typical of an inference coprocess in the previously
proposed sense.  A generic inference coprocess is expected to rely
on some data structure, possibly dependent on the rule base, which
hence requires initialization and re-initialization with the expert
system sessions.  At inference time, the coprocess data structure is
likely to be used and modified as inference progresses.</p>

<p>In the case of gating in Nclose, a record of associations between
signs and hypotheses is collected when rules are loaded and compiled
in memory.  This forward association information is implemented here
as a simple global property list.  As previously mentioned, ELisp
offers many alternatives for consideration as well.  At inference
time, whenever a sign becomes known its associated hypotheses are
posted (in no particular order) on the agenda for later evaluation.</p>

<p>Since the aspect layers are all implemented through ELisp advising
functions, the later are then required at initialization and reset
time to create and set up the gating data structure, i.e. the forward
association property list; at load-and-compile time when rules' LHSes
are parsed; and, of course, at run time when the inference process
assigns values to unknown signs.  This is a typical advice layer
architecture as provided in the <code>advice.el</code> file.</p>

<p>In particular the NClosEmacs functions that require advising functions
in this layer are:</p>

<ul>
<li>nclose-global-init</li>
<li>nclose-reset-globales</li>
</ul>

<p>to synchronize the gating data structure and sessions,</p>

<ul>
<li>sign-compile</li>
</ul>

<p>to capture associations between LHS signs and hypotheses at
load-and-compile time,</p>

<ul>
<li>sign-writer</li>
</ul>

<p>to cause associated goals to be posted on the agenda when signs become
known at inference time.</p>

<p>Using AOP gating is implemented with four advising functions at
minimal cost.</p>


<h4>The Logging Aspect Layer</h4>

<p class="first">This layer exemplifies a cross-cutting concern where a much larger
number of functions in the implementation are concerned.  Depending on
the level of details required for logging a few, some or many
functions need to be advised in this layer.</p>

<p>The current implementation logs these events:</p>

<ul>
<li>start of the inference process (<em>knowcess</em>)</li>
<li>beginning of the evaluation of a new hypothesis</li>
<li>beginning of the unification of a rule's LHS</li>
<li>beginning of the firing of a rule's RHS</li>
<li>assignment of a value to a sign</li>
</ul>

<p>Of course, adding more detailed tracing facilities is a matter of
complementing these with new advising functions for events of
interest.</p>

<p>All events are logged into a special buffer named
<code>*nclose-log*</code> and available through the usual buffer
commands in Emacs.  Note that this buffer is emptied at each session
reset and should be saved if required for later inspection.</p>



<h3>The NClose major mode</h3>

<p class="first">The NClose major mode, still pretty much work in progress at this
stage, is part of the default front-end to NClosEmacs.  The general
idea is that rule bases are simple text files edited in standard Emacs
buffers.  All major interactions with the expert system are designed
to happen from within these buffers.  Hence all user commands are
interactive Lisp functions usually invoked with the <code>M-x</code>
prefix. Of course, some NClosEmacs specific buffers, such as the log
buffer, might also be involved, or commands such as the Encyclopaedia
may also work in any buffer, but the main idea is that major user
interactions are centered around the rule base buffer itself. (Note:
this might evolve in later versions when classes/objects are added.)</p>

<p>The NClose major mode, in its current implementation, serves as a
blueprint for a comprehensive expert system dashboard.  In order to start
from a simple base, this mode is, for now, derived from the Emacs generic mode
so as to experiment with various design options.  Its major function
in this revision is to font-lock hypotheses in the rule base text to
reflect the progress of the inference process.</p>

<pre class="example">
(define-generic-mode 'nclose-mode
  '(&quot;;&quot;)
  '(&quot;add-to-kb&quot;)
  '((&quot;(@hypo[ ]+\\([a-zA-Z0-9\-]+\\))&quot; 0 (hypo-facespec (match-string 1)))

     )
  '()
  '()
  &quot;NClose-mode is a major mode for authoring and knowcessing rule bases.&quot;
)
</pre>

<p>As can be seen from the code, the major mode highlights the rule
definition keyword, and parses the rules source for hypothesis,
selecting a font according to its status (under evaluation, known true
or known false).</p>

<p>Nclose mode is invoked with <code>M-x nclose-mode</code> when in a
rule base text buffer.  It is also, in Emacs fashion, automatically
set for a buffer if the first line of the file declares:</p>

<pre class="example">
;; -*- mode: nclose -*-
</pre>

<p>a standard way to tell Emacs to switch to the appropriate major mode
when displaying this file.</p>



<h2>A Conclusion and a Starting Point</h2>

<p class="first">The NClosEmacs implementation is both a valid and complete
implementation of the NClose inference engine, as originally thought
out more than twenty five years ago, and a new base for further
research work.</p>

<p>New design choices, more specifically the leverage of the AOP and
context-oriented programming approach, which are investigated in this
implementation, open new avenues of research.  The emergence, in
particular, of inference coprocesses as a critical formulation of
extra features of the inference engine with the added benefit of an
explicit implementation technique through advising functions is one of
the remarkable facet of NClosEmacs.</p>



<!-- Page published by Emacs Muse ends here -->
  </body>
</html>
